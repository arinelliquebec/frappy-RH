package graph

// This file will be automatically regenerated based on the schema, any resolver
// implementations will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.84

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"strings"
	"time"

	"github.com/99designs/gqlgen/graphql"
	"github.com/frappyou/backend/config"
	"github.com/frappyou/backend/graph/model"
	"github.com/frappyou/backend/models"
	"github.com/google/uuid"
	"golang.org/x/crypto/bcrypt"
)

// contextKey is a custom type for context keys
type contextKey string

const (
	userIDKey contextKey = "user_id"
	roleKey   contextKey = "role"
)

// Helper to get user ID from context
func getUserIDFromContext(ctx context.Context) (string, error) {
	userID := ctx.Value(userIDKey)
	if userID == nil {
		return "", errors.New("não autorizado")
	}
	return userID.(string), nil
}

// Helper to check if user is admin
func isAdminFromContext(ctx context.Context) bool {
	role := ctx.Value(roleKey)
	if role == nil {
		return false
	}
	return role.(string) == "admin"
}

// ============== CALENDAR EVENT RESOLVER ==============

// Creator is the resolver for the creator field.
func (r *calendarEventResolver) Creator(ctx context.Context, obj *models.CalendarEvent) (*models.User, error) {
	if obj.CreatedBy == "" {
		return nil, nil
	}
	var user models.User
	if err := r.DB.First(&user, "id = ?", obj.CreatedBy).Error; err != nil {
		return nil, nil
	}
	return &user, nil
}

// ============== MUTATION RESOLVERS ==============

// Login is the resolver for the login field.
func (r *mutationResolver) Login(ctx context.Context, input model.LoginInput) (*model.AuthPayload, error) {
	cleanCPF := strings.ReplaceAll(strings.ReplaceAll(input.Cpf, ".", ""), "-", "")

	var user models.User
	err := r.DB.Where("REPLACE(REPLACE(REPLACE(cpf, '.', ''), '-', ''), ' ', '') = ?", cleanCPF).First(&user).Error
	if err != nil {
		return &model.AuthPayload{
			Success: false,
			Error:   strPtr("CPF ou senha inválidos"),
		}, nil
	}

	if err := bcrypt.CompareHashAndPassword([]byte(user.Password), []byte(input.Password)); err != nil {
		return &model.AuthPayload{
			Success: false,
			Error:   strPtr("CPF ou senha inválidos"),
		}, nil
	}

	// Generate JWT token
	rememberMe := false
	if input.RememberMe != nil {
		rememberMe = *input.RememberMe
	}
	token, err := config.GenerateToken(user.ID, user.Role, rememberMe)
	if err != nil {
		return &model.AuthPayload{
			Success: false,
			Error:   strPtr("Erro ao gerar token"),
		}, nil
	}

	return &model.AuthPayload{
		Success: true,
		Token:   &token,
		User:    &user,
	}, nil
}

// Signup is the resolver for the signup field.
func (r *mutationResolver) Signup(ctx context.Context, input model.SignupInput) (*model.AuthPayload, error) {
	// Check if email already exists
	var existingUser models.User
	if err := r.DB.Where("email = ?", input.Email).First(&existingUser).Error; err == nil {
		return &model.AuthPayload{
			Success: false,
			Error:   strPtr("Email já cadastrado"),
		}, nil
	}

	// Hash password
	hashedPassword, err := bcrypt.GenerateFromPassword([]byte(input.Password), bcrypt.DefaultCost)
	if err != nil {
		return &model.AuthPayload{
			Success: false,
			Error:   strPtr("Erro ao processar senha"),
		}, nil
	}

	user := models.User{
		ID:       uuid.New().String(),
		Name:     input.Name,
		Email:    input.Email,
		CPF:      input.Cpf,
		Password: string(hashedPassword),
		Role:     "user",
	}

	if input.Company != nil {
		user.Company = *input.Company
	}

	if err := r.DB.Create(&user).Error; err != nil {
		return &model.AuthPayload{
			Success: false,
			Error:   strPtr("Erro ao criar usuário"),
		}, nil
	}

	// Save survey answers
	surveyResponse := models.SurveyResponse{
		ID:      uuid.New().String(),
		UserID:  user.ID,
		Answers: input.Answers,
	}
	r.DB.Create(&surveyResponse)

	token, _ := config.GenerateToken(user.ID, user.Role, false)

	return &model.AuthPayload{
		Success: true,
		Token:   &token,
		User:    &user,
	}, nil
}

// Logout is the resolver for the logout field.
func (r *mutationResolver) Logout(ctx context.Context) (bool, error) {
	return true, nil
}

// ActivateAccount is the resolver for the activateAccount field.
func (r *mutationResolver) ActivateAccount(ctx context.Context, cpf string, password string) (*model.AuthPayload, error) {
	cleanCPF := strings.ReplaceAll(strings.ReplaceAll(cpf, ".", ""), "-", "")

	// Check if user already exists
	var existingUser models.User
	if err := r.DB.Where("REPLACE(REPLACE(REPLACE(cpf, '.', ''), '-', ''), ' ', '') = ?", cleanCPF).First(&existingUser).Error; err == nil {
		return &model.AuthPayload{
			Success: false,
			Error:   strPtr("Conta já ativada"),
		}, nil
	}

	// Verify CPF in collaborators table
	var colaborador struct {
		PessoaFisicaId int
		Nome           string
		Email          string
	}
	err := r.DB.Raw(`
		SELECT c.PessoaFisicaId, p.Nome, p.EmailEmpresarial as Email
		FROM dbo.ColaboradoresFradema c
		INNER JOIN dbo.PessoasFisicasFradema p ON c.PessoaFisicaId = p.Id
		WHERE p.Cpf = ? OR REPLACE(REPLACE(REPLACE(p.Cpf, '.', ''), '-', ''), ' ', '') = ?
	`, cpf, cleanCPF).Scan(&colaborador).Error

	if err != nil || colaborador.PessoaFisicaId == 0 {
		return &model.AuthPayload{
			Success: false,
			Error:   strPtr("CPF não encontrado na lista de colaboradores"),
		}, nil
	}

	hashedPassword, _ := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)

	user := models.User{
		ID:       uuid.New().String(),
		Name:     colaborador.Nome,
		Email:    colaborador.Email,
		CPF:      cpf,
		Password: string(hashedPassword),
		Role:     "user",
	}

	if err := r.DB.Create(&user).Error; err != nil {
		return &model.AuthPayload{
			Success: false,
			Error:   strPtr("Erro ao ativar conta"),
		}, nil
	}

	token, _ := config.GenerateToken(user.ID, user.Role, false)

	return &model.AuthPayload{
		Success: true,
		Token:   &token,
		User:    &user,
	}, nil
}

// CreateUser is the resolver for the createUser field.
func (r *mutationResolver) CreateUser(ctx context.Context, input model.CreateUserInput) (*models.User, error) {
	if !isAdminFromContext(ctx) {
		return nil, errors.New("acesso negado")
	}

	hashedPassword, _ := bcrypt.GenerateFromPassword([]byte(input.Password), bcrypt.DefaultCost)

	role := "user"
	if input.Role != nil {
		role = string(*input.Role)
	}

	user := models.User{
		ID:       uuid.New().String(),
		Name:     input.Name,
		Email:    input.Email,
		CPF:      input.Cpf,
		Password: string(hashedPassword),
		Role:     role,
	}

	if err := r.DB.Create(&user).Error; err != nil {
		return nil, errors.New("erro ao criar usuário")
	}

	return &user, nil
}

// UpdateUser is the resolver for the updateUser field.
func (r *mutationResolver) UpdateUser(ctx context.Context, id string, input model.UpdateUserInput) (*models.User, error) {
	if !isAdminFromContext(ctx) {
		return nil, errors.New("acesso negado")
	}

	var user models.User
	if err := r.DB.First(&user, "id = ?", id).Error; err != nil {
		return nil, errors.New("usuário não encontrado")
	}

	if input.Name != nil {
		user.Name = *input.Name
	}
	if input.Email != nil {
		user.Email = *input.Email
	}
	if input.Company != nil {
		user.Company = *input.Company
	}
	if input.Position != nil {
		user.Position = *input.Position
	}

	r.DB.Save(&user)
	return &user, nil
}

// DeleteUser is the resolver for the deleteUser field.
func (r *mutationResolver) DeleteUser(ctx context.Context, id string) (bool, error) {
	if !isAdminFromContext(ctx) {
		return false, errors.New("acesso negado")
	}

	if err := r.DB.Delete(&models.User{}, "id = ?", id).Error; err != nil {
		return false, errors.New("erro ao deletar usuário")
	}
	return true, nil
}

// ResetUserPassword is the resolver for the resetUserPassword field.
func (r *mutationResolver) ResetUserPassword(ctx context.Context, id string, newPassword string) (bool, error) {
	if !isAdminFromContext(ctx) {
		return false, errors.New("acesso negado")
	}

	hashedPassword, _ := bcrypt.GenerateFromPassword([]byte(newPassword), bcrypt.DefaultCost)
	if err := r.DB.Model(&models.User{}).Where("id = ?", id).Update("password", string(hashedPassword)).Error; err != nil {
		return false, errors.New("erro ao resetar senha")
	}
	return true, nil
}

// ToggleUserRole is the resolver for the toggleUserRole field.
func (r *mutationResolver) ToggleUserRole(ctx context.Context, id string) (*models.User, error) {
	if !isAdminFromContext(ctx) {
		return nil, errors.New("acesso negado")
	}

	var user models.User
	if err := r.DB.First(&user, "id = ?", id).Error; err != nil {
		return nil, errors.New("usuário não encontrado")
	}

	if user.Role == "admin" {
		user.Role = "user"
	} else {
		user.Role = "admin"
	}

	r.DB.Save(&user)
	return &user, nil
}

// UpdateProfile is the resolver for the updateProfile field.
func (r *mutationResolver) UpdateProfile(ctx context.Context, input model.UpdateUserInput) (*models.User, error) {
	userID, err := getUserIDFromContext(ctx)
	if err != nil {
		return nil, err
	}

	var user models.User
	if err := r.DB.First(&user, "id = ?", userID).Error; err != nil {
		return nil, errors.New("usuário não encontrado")
	}

	if input.Name != nil {
		user.Name = *input.Name
	}
	if input.Email != nil {
		user.Email = *input.Email
	}
	if input.Company != nil {
		user.Company = *input.Company
	}
	if input.Position != nil {
		user.Position = *input.Position
	}

	r.DB.Save(&user)
	return &user, nil
}

// UpdateFullProfile is the resolver for the updateFullProfile field.
func (r *mutationResolver) UpdateFullProfile(ctx context.Context, input model.UpdateProfileInput) (*model.FullProfile, error) {
	userID, err := getUserIDFromContext(ctx)
	if err != nil {
		return nil, err
	}

	// Get user CPF
	var user models.User
	if err := r.DB.First(&user, "id = ?", userID).Error; err != nil {
		return nil, errors.New("usuário não encontrado")
	}

	cleanCPF := strings.ReplaceAll(strings.ReplaceAll(user.CPF, ".", ""), "-", "")

	// Update PessoasFisicasFradema
	err = r.DB.Exec(`
		UPDATE dbo.PessoasFisicasFradema
		SET Nome = COALESCE(?, Nome),
			Codinome = COALESCE(?, Codinome),
			EmailEmpresarial = COALESCE(?, EmailEmpresarial),
			EmailPessoal = COALESCE(?, EmailPessoal),
			Telefone1 = COALESCE(?, Telefone1),
			Telefone2 = COALESCE(?, Telefone2),
			Rg = COALESCE(?, Rg),
			Cnh = COALESCE(?, Cnh),
			Sexo = COALESCE(?, Sexo),
			EstadoCivil = COALESCE(?, EstadoCivil),
			DataNascimento = COALESCE(TRY_CONVERT(date, ?), DataNascimento)
		WHERE Cpf = ? OR REPLACE(REPLACE(REPLACE(Cpf, '.', ''), '-', ''), ' ', '') = ?
	`, input.Nome, input.Codinome, input.EmailEmpresarial, input.EmailPessoal,
		input.Telefone1, input.Telefone2, input.Rg, input.Cnh, input.Sexo, input.EstadoCivil,
		input.DataNascimento, user.CPF, cleanCPF).Error

	if err != nil {
		return nil, errors.New("erro ao atualizar perfil")
	}

	// Return updated profile
	return r.Query().FullProfile(ctx)
}

// UpdateColaboradorProfile is the resolver for the updateColaboradorProfile field.
func (r *mutationResolver) UpdateColaboradorProfile(ctx context.Context, colaboradorID int, input model.UpdateProfileInput) (bool, error) {
	if !isAdminFromContext(ctx) {
		return false, errors.New("acesso negado")
	}

	// Get PessoaFisicaId
	var pessoaFisicaId int
	err := r.DB.Raw(`
		SELECT PessoaFisicaId FROM dbo.ColaboradoresFradema WHERE Id = ?
	`, colaboradorID).Scan(&pessoaFisicaId).Error

	if err != nil {
		return false, errors.New("colaborador não encontrado")
	}

	// Update PessoasFisicasFradema
	err = r.DB.Exec(`
		UPDATE dbo.PessoasFisicasFradema
		SET Nome = COALESCE(?, Nome),
			Codinome = COALESCE(?, Codinome),
			EmailEmpresarial = COALESCE(?, EmailEmpresarial),
			EmailPessoal = COALESCE(?, EmailPessoal),
			Telefone1 = COALESCE(?, Telefone1),
			Telefone2 = COALESCE(?, Telefone2),
			Rg = COALESCE(?, Rg),
			Cnh = COALESCE(?, Cnh),
			Sexo = COALESCE(?, Sexo),
			EstadoCivil = COALESCE(?, EstadoCivil),
			DataNascimento = COALESCE(TRY_CONVERT(date, ?), DataNascimento)
		WHERE Id = ?
	`, input.Nome, input.Codinome, input.EmailEmpresarial, input.EmailPessoal,
		input.Telefone1, input.Telefone2, input.Rg, input.Cnh, input.Sexo, input.EstadoCivil,
		input.DataNascimento, pessoaFisicaId).Error

	if err != nil {
		return false, errors.New("erro ao atualizar perfil")
	}

	// Update ColaboradoresFradema if needed
	if input.Cargo != nil || input.Filial != nil {
		r.DB.Exec(`
			UPDATE dbo.ColaboradoresFradema
			SET Cargo = COALESCE(?, Cargo),
				Filial = COALESCE(?, Filial)
			WHERE Id = ?
		`, input.Cargo, input.Filial, colaboradorID)
	}

	return true, nil
}

// UploadDocument is the resolver for the uploadDocument field.
func (r *mutationResolver) UploadDocument(ctx context.Context, file graphql.Upload, typeArg string, description *string) (*models.Document, error) {
	userID, err := getUserIDFromContext(ctx)
	if err != nil {
		return nil, err
	}

	// Create document record
	doc := models.Document{
		ID:           uuid.New().String(),
		UserID:       userID,
		Name:         file.Filename,
		OriginalName: file.Filename,
		Type:         typeArg,
		MimeType:     file.ContentType,
		Size:         file.Size,
		Path:         fmt.Sprintf("./uploads/documents/%s/%s", userID, file.Filename),
		Status:       models.DocumentStatusPending,
	}

	if description != nil {
		doc.Description = *description
	}

	if err := r.DB.Create(&doc).Error; err != nil {
		return nil, errors.New("erro ao salvar documento")
	}

	return &doc, nil
}

// DeleteDocument is the resolver for the deleteDocument field.
func (r *mutationResolver) DeleteDocument(ctx context.Context, id string) (bool, error) {
	userID, err := getUserIDFromContext(ctx)
	if err != nil {
		return false, err
	}

	var doc models.Document
	if err := r.DB.First(&doc, "id = ? AND user_id = ?", id, userID).Error; err != nil {
		if !isAdminFromContext(ctx) {
			return false, errors.New("documento não encontrado")
		}
	}

	if err := r.DB.Delete(&models.Document{}, "id = ?", id).Error; err != nil {
		return false, errors.New("erro ao deletar documento")
	}
	return true, nil
}

// ApproveDocument is the resolver for the approveDocument field.
func (r *mutationResolver) ApproveDocument(ctx context.Context, id string) (*models.Document, error) {
	if !isAdminFromContext(ctx) {
		return nil, errors.New("acesso negado")
	}

	userID, _ := getUserIDFromContext(ctx)
	now := time.Now()

	var doc models.Document
	if err := r.DB.First(&doc, "id = ?", id).Error; err != nil {
		return nil, errors.New("documento não encontrado")
	}

	doc.Status = models.DocumentStatusApproved
	doc.ReviewedBy = &userID
	doc.ReviewedAt = &now

	r.DB.Save(&doc)
	return &doc, nil
}

// RejectDocument is the resolver for the rejectDocument field.
func (r *mutationResolver) RejectDocument(ctx context.Context, id string, reason string) (*models.Document, error) {
	if !isAdminFromContext(ctx) {
		return nil, errors.New("acesso negado")
	}

	userID, _ := getUserIDFromContext(ctx)
	now := time.Now()

	var doc models.Document
	if err := r.DB.First(&doc, "id = ?", id).Error; err != nil {
		return nil, errors.New("documento não encontrado")
	}

	doc.Status = models.DocumentStatusRejected
	doc.ReviewedBy = &userID
	doc.ReviewedAt = &now
	doc.RejectReason = reason

	r.DB.Save(&doc)
	return &doc, nil
}

// CreateVacation is the resolver for the createVacation field.
func (r *mutationResolver) CreateVacation(ctx context.Context, input model.CreateVacationInput) (*models.Vacation, error) {
	userID, err := getUserIDFromContext(ctx)
	if err != nil {
		return nil, err
	}

	startDate, _ := time.Parse("2006-01-02", input.StartDate)
	endDate, _ := time.Parse("2006-01-02", input.EndDate)
	totalDays := int(endDate.Sub(startDate).Hours()/24) + 1

	vacation := models.Vacation{
		ID:        uuid.New().String(),
		UserID:    userID,
		Type:      models.VacationType(input.Type),
		StartDate: startDate,
		EndDate:   endDate,
		TotalDays: totalDays,
		Status:    models.VacationStatusPending,
	}

	if input.Reason != nil {
		vacation.Reason = *input.Reason
	}
	if input.Notes != nil {
		vacation.Notes = *input.Notes
	}

	if err := r.DB.Create(&vacation).Error; err != nil {
		return nil, errors.New("erro ao criar solicitação")
	}

	return &vacation, nil
}

// UpdateVacation is the resolver for the updateVacation field.
func (r *mutationResolver) UpdateVacation(ctx context.Context, id string, input model.UpdateVacationInput) (*models.Vacation, error) {
	userID, err := getUserIDFromContext(ctx)
	if err != nil {
		return nil, err
	}

	var vacation models.Vacation
	if err := r.DB.First(&vacation, "id = ? AND user_id = ?", id, userID).Error; err != nil {
		return nil, errors.New("solicitação não encontrada")
	}

	if input.Type != nil {
		vacation.Type = models.VacationType(*input.Type)
	}
	if input.StartDate != nil {
		startDate, _ := time.Parse("2006-01-02", *input.StartDate)
		vacation.StartDate = startDate
	}
	if input.EndDate != nil {
		endDate, _ := time.Parse("2006-01-02", *input.EndDate)
		vacation.EndDate = endDate
	}
	if input.Reason != nil {
		vacation.Reason = *input.Reason
	}
	if input.Notes != nil {
		vacation.Notes = *input.Notes
	}

	vacation.TotalDays = int(vacation.EndDate.Sub(vacation.StartDate).Hours()/24) + 1

	r.DB.Save(&vacation)
	return &vacation, nil
}

// DeleteVacation is the resolver for the deleteVacation field.
func (r *mutationResolver) DeleteVacation(ctx context.Context, id string) (bool, error) {
	if !isAdminFromContext(ctx) {
		return false, errors.New("acesso negado")
	}

	if err := r.DB.Delete(&models.Vacation{}, "id = ?", id).Error; err != nil {
		return false, errors.New("erro ao deletar solicitação")
	}
	return true, nil
}

// ApproveVacation is the resolver for the approveVacation field.
func (r *mutationResolver) ApproveVacation(ctx context.Context, id string, input model.VacationApprovalInput) (*models.Vacation, error) {
	if !isAdminFromContext(ctx) {
		return nil, errors.New("acesso negado")
	}

	userID, _ := getUserIDFromContext(ctx)
	now := time.Now()

	var vacation models.Vacation
	if err := r.DB.First(&vacation, "id = ?", id).Error; err != nil {
		return nil, errors.New("solicitação não encontrada")
	}

	vacation.Status = models.VacationStatus(input.Status)
	vacation.ApprovedBy = &userID
	vacation.ApprovedAt = &now

	if input.RejectReason != nil {
		vacation.RejectReason = *input.RejectReason
	}

	r.DB.Save(&vacation)
	return &vacation, nil
}

// CancelVacation is the resolver for the cancelVacation field.
func (r *mutationResolver) CancelVacation(ctx context.Context, id string) (*models.Vacation, error) {
	userID, err := getUserIDFromContext(ctx)
	if err != nil {
		return nil, err
	}

	var vacation models.Vacation
	query := r.DB.Where("id = ?", id)
	if !isAdminFromContext(ctx) {
		query = query.Where("user_id = ?", userID)
	}

	if err := query.First(&vacation).Error; err != nil {
		return nil, errors.New("solicitação não encontrada")
	}

	vacation.Status = models.VacationStatusCanceled
	r.DB.Save(&vacation)
	return &vacation, nil
}

// CreateCalendarEvent is the resolver for the createCalendarEvent field.
func (r *mutationResolver) CreateCalendarEvent(ctx context.Context, input model.CreateCalendarEventInput) (*models.CalendarEvent, error) {
	if !isAdminFromContext(ctx) {
		return nil, errors.New("acesso negado")
	}

	userID, _ := getUserIDFromContext(ctx)
	startDate, _ := time.Parse("2006-01-02", input.StartDate)
	endDate, _ := time.Parse("2006-01-02", input.EndDate)

	event := models.CalendarEvent{
		ID:        uuid.New().String(),
		Title:     input.Title,
		Type:      input.Type,
		StartDate: startDate,
		EndDate:   endDate,
		CreatedBy: userID,
	}

	if input.Description != nil {
		event.Description = *input.Description
	}
	if input.Color != nil {
		event.Color = *input.Color
	}
	if input.AllDay != nil {
		event.AllDay = *input.AllDay
	}

	if err := r.DB.Create(&event).Error; err != nil {
		return nil, errors.New("erro ao criar evento")
	}

	return &event, nil
}

// UpdateCalendarEvent is the resolver for the updateCalendarEvent field.
func (r *mutationResolver) UpdateCalendarEvent(ctx context.Context, id string, input model.UpdateCalendarEventInput) (*models.CalendarEvent, error) {
	if !isAdminFromContext(ctx) {
		return nil, errors.New("acesso negado")
	}

	var event models.CalendarEvent
	if err := r.DB.First(&event, "id = ?", id).Error; err != nil {
		return nil, errors.New("evento não encontrado")
	}

	if input.Title != nil {
		event.Title = *input.Title
	}
	if input.Description != nil {
		event.Description = *input.Description
	}
	if input.Type != nil {
		event.Type = *input.Type
	}
	if input.StartDate != nil {
		startDate, _ := time.Parse("2006-01-02", *input.StartDate)
		event.StartDate = startDate
	}
	if input.EndDate != nil {
		endDate, _ := time.Parse("2006-01-02", *input.EndDate)
		event.EndDate = endDate
	}
	if input.Color != nil {
		event.Color = *input.Color
	}
	if input.AllDay != nil {
		event.AllDay = *input.AllDay
	}

	r.DB.Save(&event)
	return &event, nil
}

// DeleteCalendarEvent is the resolver for the deleteCalendarEvent field.
func (r *mutationResolver) DeleteCalendarEvent(ctx context.Context, id string) (bool, error) {
	if !isAdminFromContext(ctx) {
		return false, errors.New("acesso negado")
	}

	if err := r.DB.Delete(&models.CalendarEvent{}, "id = ?", id).Error; err != nil {
		return false, errors.New("erro ao deletar evento")
	}
	return true, nil
}

// SubmitSurvey is the resolver for the submitSurvey field.
func (r *mutationResolver) SubmitSurvey(ctx context.Context, answers string) (*models.SurveyResults, error) {
	userID, err := getUserIDFromContext(ctx)
	if err != nil {
		return nil, err
	}

	// Parse answers
	var answersMap map[int]int
	if err := json.Unmarshal([]byte(answers), &answersMap); err != nil {
		return nil, errors.New("formato de respostas inválido")
	}

	score := models.CalculateSurveyScore(answersMap)

	// Save survey response
	surveyResponse := models.SurveyResponse{
		ID:      uuid.New().String(),
		UserID:  userID,
		Answers: answers,
		Score:   score,
	}

	// Check if already exists
	var existing models.SurveyResponse
	if err := r.DB.Where("user_id = ?", userID).First(&existing).Error; err == nil {
		existing.Answers = answers
		existing.Score = score
		r.DB.Save(&existing)
	} else {
		r.DB.Create(&surveyResponse)
	}

	return &models.SurveyResults{
		UserID:       userID,
		OverallScore: score,
		CreatedAt:    time.Now(),
	}, nil
}

// ============== QUERY RESOLVERS ==============

// Me is the resolver for the me field.
func (r *queryResolver) Me(ctx context.Context) (*models.User, error) {
	userID, err := getUserIDFromContext(ctx)
	if err != nil {
		return nil, err
	}

	var user models.User
	if err := r.DB.First(&user, "id = ?", userID).Error; err != nil {
		return nil, errors.New("usuário não encontrado")
	}
	return &user, nil
}

// User is the resolver for the user field.
func (r *queryResolver) User(ctx context.Context, id string) (*models.User, error) {
	var user models.User
	if err := r.DB.First(&user, "id = ?", id).Error; err != nil {
		return nil, errors.New("usuário não encontrado")
	}
	return &user, nil
}

// Users is the resolver for the users field.
func (r *queryResolver) Users(ctx context.Context, search *string, page *int, perPage *int) (*model.UserConnection, error) {
	if !isAdminFromContext(ctx) {
		return nil, errors.New("acesso negado")
	}

	query := r.DB.Model(&models.User{})

	if search != nil && *search != "" {
		searchTerm := "%" + *search + "%"
		query = query.Where("name LIKE ? OR email LIKE ? OR cpf LIKE ?", searchTerm, searchTerm, searchTerm)
	}

	var total int64
	query.Count(&total)

	pageNum := 1
	perPageNum := 20
	if page != nil {
		pageNum = *page
	}
	if perPage != nil {
		perPageNum = *perPage
	}

	offset := (pageNum - 1) * perPageNum
	totalPages := int((total + int64(perPageNum) - 1) / int64(perPageNum))

	var users []*models.User
	query.Offset(offset).Limit(perPageNum).Order("name").Find(&users)

	return &model.UserConnection{
		Nodes:      users,
		TotalCount: int(total),
		PageInfo: &model.PageInfo{
			HasNextPage:     pageNum < totalPages,
			HasPreviousPage: pageNum > 1,
			CurrentPage:     pageNum,
			TotalPages:      totalPages,
		},
	}, nil
}

// Colaboradores is the resolver for the colaboradores field.
func (r *queryResolver) Colaboradores(ctx context.Context, filter *model.ColaboradorFilterInput, page *int, perPage *int) (*model.ColaboradorConnection, error) {
	if !isAdminFromContext(ctx) {
		return nil, errors.New("acesso negado")
	}

	whereClause := "WHERE 1=1"
	args := []interface{}{}

	if filter != nil {
		if filter.Search != nil && *filter.Search != "" {
			whereClause += " AND (p.Nome LIKE ? OR REPLACE(REPLACE(REPLACE(p.Cpf, '.', ''), '-', ''), ' ', '') LIKE ?)"
			searchTerm := "%" + *filter.Search + "%"
			args = append(args, searchTerm, searchTerm)
		}
		if filter.Filial != nil && *filter.Filial != "" {
			whereClause += " AND c.Filial = ?"
			args = append(args, *filter.Filial)
		}
	}

	var total int64
	r.DB.Raw(fmt.Sprintf(`
		SELECT COUNT(*)
		FROM dbo.ColaboradoresFradema c
		INNER JOIN dbo.PessoasFisicasFradema p ON c.PessoaFisicaId = p.Id
		%s
	`, whereClause), args...).Scan(&total)

	pageNum := 1
	perPageNum := 50
	if page != nil {
		pageNum = *page
	}
	if perPage != nil {
		perPageNum = *perPage
	}
	offset := (pageNum - 1) * perPageNum

	var colaboradores []*model.Colaborador
	r.DB.Raw(fmt.Sprintf(`
		SELECT c.Id, p.Cpf, p.Nome, p.Codinome, p.EmailEmpresarial, p.EmailPessoal,
			   p.Telefone1, p.Telefone2, p.Rg, p.Cnh, p.Sexo, p.EstadoCivil,
			   CONVERT(varchar(10), p.DataNascimento, 120) as DataNascimento,
			   c.Cargo, c.Filial, c.Ativo
		FROM dbo.ColaboradoresFradema c
		INNER JOIN dbo.PessoasFisicasFradema p ON c.PessoaFisicaId = p.Id
		%s
		ORDER BY p.Nome
		OFFSET ? ROWS FETCH NEXT ? ROWS ONLY
	`, whereClause), append(args, offset, perPageNum)...).Scan(&colaboradores)

	// Check which have system users
	for _, c := range colaboradores {
		if c.Cpf != nil {
			var count int64
			cleanCPF := strings.ReplaceAll(strings.ReplaceAll(*c.Cpf, ".", ""), "-", "")
			r.DB.Model(&models.User{}).Where("REPLACE(REPLACE(REPLACE(cpf, '.', ''), '-', ''), ' ', '') = ?", cleanCPF).Count(&count)
			c.HasSystemUser = count > 0
		}
	}

	return &model.ColaboradorConnection{
		Nodes:      colaboradores,
		TotalCount: int(total),
	}, nil
}

// Colaborador is the resolver for the colaborador field.
func (r *queryResolver) Colaborador(ctx context.Context, id int) (*model.Colaborador, error) {
	var colaborador model.Colaborador
	err := r.DB.Raw(`
		SELECT c.Id, p.Cpf, p.Nome, p.Codinome, p.EmailEmpresarial, p.EmailPessoal,
			   p.Telefone1, p.Telefone2, p.Rg, p.Cnh, p.Sexo, p.EstadoCivil,
			   CONVERT(varchar(10), p.DataNascimento, 120) as DataNascimento,
			   c.Cargo, c.Filial, c.Ativo
		FROM dbo.ColaboradoresFradema c
		INNER JOIN dbo.PessoasFisicasFradema p ON c.PessoaFisicaId = p.Id
		WHERE c.Id = ?
	`, id).Scan(&colaborador).Error

	if err != nil {
		return nil, errors.New("colaborador não encontrado")
	}

	return &colaborador, nil
}

// SearchColaboradores is the resolver for the searchColaboradores field.
func (r *queryResolver) SearchColaboradores(ctx context.Context, search string) ([]*model.Colaborador, error) {
	searchTerm := "%" + search + "%"
	cleanSearch := strings.ReplaceAll(strings.ReplaceAll(search, ".", ""), "-", "")

	var colaboradores []*model.Colaborador
	r.DB.Raw(`
		SELECT TOP 10 c.Id, p.Cpf, p.Nome, p.Codinome, p.EmailEmpresarial, p.EmailPessoal,
			   p.Telefone1, p.Telefone2, p.Rg, p.Cnh, p.Sexo, p.EstadoCivil,
			   CONVERT(varchar(10), p.DataNascimento, 120) as DataNascimento,
			   c.Cargo, c.Filial, c.Ativo
		FROM dbo.ColaboradoresFradema c
		INNER JOIN dbo.PessoasFisicasFradema p ON c.PessoaFisicaId = p.Id
		WHERE p.Nome LIKE ? OR REPLACE(REPLACE(REPLACE(p.Cpf, '.', ''), '-', ''), ' ', '') LIKE ?
		ORDER BY p.Nome
	`, searchTerm, "%"+cleanSearch+"%").Scan(&colaboradores)

	// Check which have system users
	for _, c := range colaboradores {
		if c.Cpf != nil {
			var count int64
			cleanCPF := strings.ReplaceAll(strings.ReplaceAll(*c.Cpf, ".", ""), "-", "")
			r.DB.Model(&models.User{}).Where("REPLACE(REPLACE(REPLACE(cpf, '.', ''), '-', ''), ' ', '') = ?", cleanCPF).Count(&count)
			c.HasSystemUser = count > 0

			if c.HasSystemUser {
				var user models.User
				r.DB.Where("REPLACE(REPLACE(REPLACE(cpf, '.', ''), '-', ''), ' ', '') = ?", cleanCPF).First(&user)
				c.SystemUserID = &user.ID
			}
		}
	}

	return colaboradores, nil
}

// Filiais is the resolver for the filiais field.
func (r *queryResolver) Filiais(ctx context.Context) ([]*model.Filial, error) {
	var filiais []string
	r.DB.Raw(`
		SELECT Nome
		FROM dbo.Filiais
		WHERE Nome IS NOT NULL AND LTRIM(RTRIM(Nome)) != ''
		ORDER BY Nome
	`).Scan(&filiais)

	result := make([]*model.Filial, len(filiais))
	for i, f := range filiais {
		result[i] = &model.Filial{Nome: f}
	}
	return result, nil
}

// FullProfile is the resolver for the fullProfile field.
func (r *queryResolver) FullProfile(ctx context.Context) (*model.FullProfile, error) {
	userID, err := getUserIDFromContext(ctx)
	if err != nil {
		return nil, err
	}

	var user models.User
	if err := r.DB.First(&user, "id = ?", userID).Error; err != nil {
		return nil, errors.New("usuário não encontrado")
	}

	cleanCPF := strings.ReplaceAll(strings.ReplaceAll(user.CPF, ".", ""), "-", "")

	var profile model.FullProfile
	err = r.DB.Raw(`
		SELECT c.Id, p.Cpf, p.Nome, p.Codinome, p.EmailEmpresarial, p.EmailPessoal,
			   p.Telefone1, p.Telefone2, p.Rg, p.Cnh, p.Sexo, p.EstadoCivil,
			   CONVERT(varchar(10), p.DataNascimento, 120) as DataNascimento,
			   c.Cargo, c.Filial
		FROM dbo.ColaboradoresFradema c
		INNER JOIN dbo.PessoasFisicasFradema p ON c.PessoaFisicaId = p.Id
		WHERE p.Cpf = ? OR REPLACE(REPLACE(REPLACE(p.Cpf, '.', ''), '-', ''), ' ', '') = ?
	`, user.CPF, cleanCPF).Scan(&profile).Error

	if err != nil {
		return nil, errors.New("perfil não encontrado")
	}

	return &profile, nil
}

// ColaboradorProfile is the resolver for the colaboradorProfile field.
func (r *queryResolver) ColaboradorProfile(ctx context.Context, colaboradorID int) (*model.FullProfile, error) {
	if !isAdminFromContext(ctx) {
		return nil, errors.New("acesso negado")
	}

	var profile model.FullProfile
	err := r.DB.Raw(`
		SELECT c.Id, p.Cpf, p.Nome, p.Codinome, p.EmailEmpresarial, p.EmailPessoal,
			   p.Telefone1, p.Telefone2, p.Rg, p.Cnh, p.Sexo, p.EstadoCivil,
			   CONVERT(varchar(10), p.DataNascimento, 120) as DataNascimento,
			   c.Cargo, c.Filial
		FROM dbo.ColaboradoresFradema c
		INNER JOIN dbo.PessoasFisicasFradema p ON c.PessoaFisicaId = p.Id
		WHERE c.Id = ?
	`, colaboradorID).Scan(&profile).Error

	if err != nil {
		return nil, errors.New("perfil não encontrado")
	}

	return &profile, nil
}

// Documents is the resolver for the documents field.
func (r *queryResolver) Documents(ctx context.Context, filter *model.DocumentFilterInput, page *int, perPage *int) (*model.DocumentConnection, error) {
	if !isAdminFromContext(ctx) {
		return nil, errors.New("acesso negado")
	}

	query := r.DB.Model(&models.Document{})

	if filter != nil {
		if filter.UserID != nil {
			query = query.Where("user_id = ?", *filter.UserID)
		}
		if filter.Status != nil {
			query = query.Where("status = ?", *filter.Status)
		}
		if filter.Type != nil {
			query = query.Where("type = ?", *filter.Type)
		}
	}

	var total int64
	query.Count(&total)

	pageNum := 1
	perPageNum := 20
	if page != nil {
		pageNum = *page
	}
	if perPage != nil {
		perPageNum = *perPage
	}

	offset := (pageNum - 1) * perPageNum
	totalPages := int((total + int64(perPageNum) - 1) / int64(perPageNum))

	var documents []*models.Document
	query.Offset(offset).Limit(perPageNum).Order("created_at DESC").Preload("User").Find(&documents)

	return &model.DocumentConnection{
		Nodes:      documents,
		TotalCount: int(total),
		PageInfo: &model.PageInfo{
			HasNextPage:     pageNum < totalPages,
			HasPreviousPage: pageNum > 1,
			CurrentPage:     pageNum,
			TotalPages:      totalPages,
		},
	}, nil
}

// Document is the resolver for the document field.
func (r *queryResolver) Document(ctx context.Context, id string) (*models.Document, error) {
	var doc models.Document
	if err := r.DB.Preload("User").First(&doc, "id = ?", id).Error; err != nil {
		return nil, errors.New("documento não encontrado")
	}
	return &doc, nil
}

// MyDocuments is the resolver for the myDocuments field.
func (r *queryResolver) MyDocuments(ctx context.Context) ([]*models.Document, error) {
	userID, err := getUserIDFromContext(ctx)
	if err != nil {
		return nil, err
	}

	var documents []*models.Document
	r.DB.Where("user_id = ?", userID).Order("created_at DESC").Find(&documents)
	return documents, nil
}

// DocumentStats is the resolver for the documentStats field.
func (r *queryResolver) DocumentStats(ctx context.Context) (*model.DocumentStats, error) {
	if !isAdminFromContext(ctx) {
		return nil, errors.New("acesso negado")
	}

	var total, pending, approved, rejected int64
	r.DB.Model(&models.Document{}).Count(&total)
	r.DB.Model(&models.Document{}).Where("status = ?", "pending").Count(&pending)
	r.DB.Model(&models.Document{}).Where("status = ?", "approved").Count(&approved)
	r.DB.Model(&models.Document{}).Where("status = ?", "rejected").Count(&rejected)

	return &model.DocumentStats{
		TotalDocuments:    int(total),
		PendingDocuments:  int(pending),
		ApprovedDocuments: int(approved),
		RejectedDocuments: int(rejected),
	}, nil
}

// Vacations is the resolver for the vacations field.
func (r *queryResolver) Vacations(ctx context.Context, filter *model.VacationFilterInput, page *int, perPage *int) (*model.VacationConnection, error) {
	if !isAdminFromContext(ctx) {
		return nil, errors.New("acesso negado")
	}

	query := r.DB.Model(&models.Vacation{})

	if filter != nil {
		if filter.UserID != nil {
			query = query.Where("user_id = ?", *filter.UserID)
		}
		if filter.Type != nil {
			query = query.Where("type = ?", *filter.Type)
		}
		if filter.Status != nil {
			query = query.Where("status = ?", *filter.Status)
		}
	}

	var total int64
	query.Count(&total)

	pageNum := 1
	perPageNum := 20
	if page != nil {
		pageNum = *page
	}
	if perPage != nil {
		perPageNum = *perPage
	}

	offset := (pageNum - 1) * perPageNum
	totalPages := int((total + int64(perPageNum) - 1) / int64(perPageNum))

	var vacations []*models.Vacation
	query.Offset(offset).Limit(perPageNum).Order("created_at DESC").Preload("User").Find(&vacations)

	return &model.VacationConnection{
		Nodes:      vacations,
		TotalCount: int(total),
		PageInfo: &model.PageInfo{
			HasNextPage:     pageNum < totalPages,
			HasPreviousPage: pageNum > 1,
			CurrentPage:     pageNum,
			TotalPages:      totalPages,
		},
	}, nil
}

// Vacation is the resolver for the vacation field.
func (r *queryResolver) Vacation(ctx context.Context, id string) (*models.Vacation, error) {
	var vacation models.Vacation
	if err := r.DB.Preload("User").First(&vacation, "id = ?", id).Error; err != nil {
		return nil, errors.New("solicitação não encontrada")
	}
	return &vacation, nil
}

// MyVacations is the resolver for the myVacations field.
func (r *queryResolver) MyVacations(ctx context.Context) ([]*models.Vacation, error) {
	userID, err := getUserIDFromContext(ctx)
	if err != nil {
		return nil, err
	}

	var vacations []*models.Vacation
	r.DB.Where("user_id = ?", userID).Order("created_at DESC").Find(&vacations)
	return vacations, nil
}

// MyVacationBalance is the resolver for the myVacationBalance field.
func (r *queryResolver) MyVacationBalance(ctx context.Context) (*models.VacationBalance, error) {
	userID, err := getUserIDFromContext(ctx)
	if err != nil {
		return nil, err
	}

	var balance models.VacationBalance
	if err := r.DB.Where("user_id = ?", userID).First(&balance).Error; err != nil {
		// Create default balance
		balance = models.VacationBalance{
			ID:            uuid.New().String(),
			UserID:        userID,
			TotalDays:     30,
			UsedDays:      0,
			PendingDays:   0,
			AvailableDays: 30,
			PeriodStart:   time.Now(),
			PeriodEnd:     time.Now().AddDate(1, 0, 0),
			AbonoDays:     3,
			UsedAbono:     0,
		}
		r.DB.Create(&balance)
	}
	return &balance, nil
}

// VacationStats is the resolver for the vacationStats field.
func (r *queryResolver) VacationStats(ctx context.Context) (*models.VacationStats, error) {
	if !isAdminFromContext(ctx) {
		return nil, errors.New("acesso negado")
	}

	var stats models.VacationStats
	r.DB.Model(&models.Vacation{}).Count(&stats.TotalRequests)
	r.DB.Model(&models.Vacation{}).Where("status = ?", "pending").Count(&stats.PendingRequests)
	r.DB.Model(&models.Vacation{}).Where("status = ?", "approved").Count(&stats.ApprovedRequests)
	r.DB.Model(&models.Vacation{}).Where("status = ?", "rejected").Count(&stats.RejectedRequests)

	return &stats, nil
}

// TeamVacations is the resolver for the teamVacations field.
func (r *queryResolver) TeamVacations(ctx context.Context, month *int, year *int) ([]*models.Vacation, error) {
	query := r.DB.Model(&models.Vacation{}).Where("status = ?", "approved")

	if month != nil && year != nil {
		startDate := time.Date(*year, time.Month(*month), 1, 0, 0, 0, 0, time.UTC)
		endDate := startDate.AddDate(0, 1, -1)
		query = query.Where("(start_date BETWEEN ? AND ?) OR (end_date BETWEEN ? AND ?)", startDate, endDate, startDate, endDate)
	}

	var vacations []*models.Vacation
	query.Preload("User").Find(&vacations)
	return vacations, nil
}

// CalendarEvents is the resolver for the calendarEvents field.
func (r *queryResolver) CalendarEvents(ctx context.Context, startDate *string, endDate *string) ([]*models.CalendarEvent, error) {
	query := r.DB.Model(&models.CalendarEvent{})

	if startDate != nil && endDate != nil {
		start, _ := time.Parse("2006-01-02", *startDate)
		end, _ := time.Parse("2006-01-02", *endDate)
		query = query.Where("(start_date BETWEEN ? AND ?) OR (end_date BETWEEN ? AND ?)", start, end, start, end)
	}

	var events []*models.CalendarEvent
	query.Order("start_date").Find(&events)
	return events, nil
}

// CalendarEvent is the resolver for the calendarEvent field.
func (r *queryResolver) CalendarEvent(ctx context.Context, id string) (*models.CalendarEvent, error) {
	var event models.CalendarEvent
	if err := r.DB.First(&event, "id = ?", id).Error; err != nil {
		return nil, errors.New("evento não encontrado")
	}
	return &event, nil
}

// SurveyQuestions is the resolver for the surveyQuestions field.
func (r *queryResolver) SurveyQuestions(ctx context.Context) ([]*model.SurveyQuestion, error) {
	questions := models.GetSurveyQuestions()
	result := make([]*model.SurveyQuestion, len(questions))
	for i, q := range questions {
		result[i] = &model.SurveyQuestion{
			ID:             q.ID,
			Text:           q.Text,
			ScaleType:      q.ScaleType,
			ScaleDirection: q.ScaleDirection,
			Category:       q.Category,
		}
	}
	return result, nil
}

// MySurveyResults is the resolver for the mySurveyResults field.
func (r *queryResolver) MySurveyResults(ctx context.Context) (*models.SurveyResults, error) {
	userID, err := getUserIDFromContext(ctx)
	if err != nil {
		return nil, err
	}

	var surveyResponse models.SurveyResponse
	if err := r.DB.Where("user_id = ?", userID).First(&surveyResponse).Error; err != nil {
		return nil, nil
	}

	return &models.SurveyResults{
		UserID:       userID,
		OverallScore: surveyResponse.Score,
		CreatedAt:    surveyResponse.CreatedAt,
	}, nil
}

// DashboardStats is the resolver for the dashboardStats field.
func (r *queryResolver) DashboardStats(ctx context.Context) (*model.DashboardStats, error) {
	if !isAdminFromContext(ctx) {
		return nil, errors.New("acesso negado")
	}

	var totalUsers, totalAdmins, totalDocs, pendingDocs, totalVac, pendingVac int64
	r.DB.Model(&models.User{}).Count(&totalUsers)
	r.DB.Model(&models.User{}).Where("role = ?", "admin").Count(&totalAdmins)
	r.DB.Model(&models.Document{}).Count(&totalDocs)
	r.DB.Model(&models.Document{}).Where("status = ?", "pending").Count(&pendingDocs)
	r.DB.Model(&models.Vacation{}).Count(&totalVac)
	r.DB.Model(&models.Vacation{}).Where("status = ?", "pending").Count(&pendingVac)

	return &model.DashboardStats{
		TotalUsers:       int(totalUsers),
		TotalAdmins:      int(totalAdmins),
		TotalDocuments:   int(totalDocs),
		PendingDocuments: int(pendingDocs),
		TotalVacations:   int(totalVac),
		PendingVacations: int(pendingVac),
	}, nil
}

// AuditLogs is the resolver for the auditLogs field.
func (r *queryResolver) AuditLogs(ctx context.Context, userID *string, page *int, perPage *int) ([]*models.AuditLog, error) {
	if !isAdminFromContext(ctx) {
		return nil, errors.New("acesso negado")
	}

	query := r.DB.Model(&models.AuditLog{})

	if userID != nil {
		query = query.Where("entity_id = ?", *userID)
	}

	pageNum := 1
	perPageNum := 50
	if page != nil {
		pageNum = *page
	}
	if perPage != nil {
		perPageNum = *perPage
	}

	offset := (pageNum - 1) * perPageNum

	var logs []*models.AuditLog
	query.Offset(offset).Limit(perPageNum).Order("created_at DESC").Find(&logs)
	return logs, nil
}

// ValidateCpf is the resolver for the validateCPF field.
func (r *queryResolver) ValidateCpf(ctx context.Context, cpf string) (*model.CPFValidation, error) {
	cleanCPF := strings.ReplaceAll(strings.ReplaceAll(cpf, ".", ""), "-", "")

	var colaborador struct {
		Id   int
		Nome string
	}

	err := r.DB.Raw(`
		SELECT c.Id, p.Nome
		FROM dbo.ColaboradoresFradema c
		INNER JOIN dbo.PessoasFisicasFradema p ON c.PessoaFisicaId = p.Id
		WHERE p.Cpf = ? OR REPLACE(REPLACE(REPLACE(p.Cpf, '.', ''), '-', ''), ' ', '') = ?
	`, cpf, cleanCPF).Scan(&colaborador).Error

	if err != nil || colaborador.Id == 0 {
		return &model.CPFValidation{
			Valid:         false,
			HasSystemUser: false,
			Message:       strPtr("CPF não encontrado na lista de colaboradores"),
		}, nil
	}

	// Check if has system user
	var count int64
	r.DB.Model(&models.User{}).Where("REPLACE(REPLACE(REPLACE(cpf, '.', ''), '-', ''), ' ', '') = ?", cleanCPF).Count(&count)

	return &model.CPFValidation{
		Valid:         true,
		ColaboradorID: &colaborador.Id,
		Nome:          &colaborador.Nome,
		HasSystemUser: count > 0,
		Message:       strPtr("CPF válido"),
	}, nil
}

// ============== SUBSCRIPTION RESOLVERS ==============

// VacationUpdated is the resolver for the vacationUpdated field.
func (r *subscriptionResolver) VacationUpdated(ctx context.Context) (<-chan *models.Vacation, error) {
	// TODO: Implement WebSocket subscriptions
	return nil, errors.New("subscriptions não implementadas")
}

// DocumentUpdated is the resolver for the documentUpdated field.
func (r *subscriptionResolver) DocumentUpdated(ctx context.Context) (<-chan *models.Document, error) {
	return nil, errors.New("subscriptions não implementadas")
}

// NewNotification is the resolver for the newNotification field.
func (r *subscriptionResolver) NewNotification(ctx context.Context) (<-chan *model.Notification, error) {
	return nil, errors.New("subscriptions não implementadas")
}

// ============== TYPE RESOLVERS ==============

// Categories is the resolver for the categories field.
func (r *surveyResultsResolver) Categories(ctx context.Context, obj *models.SurveyResults) (*model.CategoryScores, error) {
	if obj.Categories == nil {
		return &model.CategoryScores{}, nil
	}
	return &model.CategoryScores{
		Demandas:        obj.Categories["demandas"],
		Controle:        obj.Categories["controle"],
		Apoio:           obj.Categories["apoio"],
		Relacionamentos: obj.Categories["relacionamentos"],
		Papel:           obj.Categories["papel"],
		Mudanca:         obj.Categories["mudanca"],
	}, nil
}

// Role is the resolver for the role field.
func (r *userResolver) Role(ctx context.Context, obj *models.User) (model.UserRole, error) {
	if obj.Role == "admin" {
		return model.UserRoleAdmin, nil
	}
	return model.UserRoleUser, nil
}

// Documents is the resolver for the documents field.
func (r *userResolver) Documents(ctx context.Context, obj *models.User) ([]*models.Document, error) {
	var documents []*models.Document
	r.DB.Where("user_id = ?", obj.ID).Find(&documents)
	return documents, nil
}

// Vacations is the resolver for the vacations field.
func (r *userResolver) Vacations(ctx context.Context, obj *models.User) ([]*models.Vacation, error) {
	var vacations []*models.Vacation
	r.DB.Where("user_id = ?", obj.ID).Find(&vacations)
	return vacations, nil
}

// VacationBalance is the resolver for the vacationBalance field.
func (r *userResolver) VacationBalance(ctx context.Context, obj *models.User) (*models.VacationBalance, error) {
	var balance models.VacationBalance
	if err := r.DB.Where("user_id = ?", obj.ID).First(&balance).Error; err != nil {
		return nil, nil
	}
	return &balance, nil
}

// SurveyResponse is the resolver for the surveyResponse field.
func (r *userResolver) SurveyResponse(ctx context.Context, obj *models.User) (*models.SurveyResponse, error) {
	var response models.SurveyResponse
	if err := r.DB.Where("user_id = ?", obj.ID).First(&response).Error; err != nil {
		return nil, nil
	}
	return &response, nil
}

// PendingFerias is the resolver for the pendingFerias field.
func (r *vacationStatsResolver) PendingFerias(ctx context.Context, obj *models.VacationStats) (int, error) {
	var count int64
	r.DB.Model(&models.Vacation{}).Where("status = ? AND type = ?", "pending", "ferias").Count(&count)
	return int(count), nil
}

// PendingAusencias is the resolver for the pendingAusencias field.
func (r *vacationStatsResolver) PendingAusencias(ctx context.Context, obj *models.VacationStats) (int, error) {
	var count int64
	r.DB.Model(&models.Vacation{}).Where("status = ? AND type != ?", "pending", "ferias").Count(&count)
	return int(count), nil
}

// CalendarEvent returns CalendarEventResolver implementation.
func (r *Resolver) CalendarEvent() CalendarEventResolver { return &calendarEventResolver{r} }

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// Subscription returns SubscriptionResolver implementation.
func (r *Resolver) Subscription() SubscriptionResolver { return &subscriptionResolver{r} }

// SurveyResults returns SurveyResultsResolver implementation.
func (r *Resolver) SurveyResults() SurveyResultsResolver { return &surveyResultsResolver{r} }

// User returns UserResolver implementation.
func (r *Resolver) User() UserResolver { return &userResolver{r} }

// VacationStats returns VacationStatsResolver implementation.
func (r *Resolver) VacationStats() VacationStatsResolver { return &vacationStatsResolver{r} }

type calendarEventResolver struct{ *Resolver }
type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type subscriptionResolver struct{ *Resolver }
type surveyResultsResolver struct{ *Resolver }
type userResolver struct{ *Resolver }
type vacationStatsResolver struct{ *Resolver }

// Helper functions
func strPtr(s string) *string {
	return &s
}

func intPtr(i int) *int {
	return &i
}
